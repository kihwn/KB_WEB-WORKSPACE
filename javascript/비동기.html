<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <p>
        컴퓨터는 기본적으로 동기식 처리를 한다.<br/>
        동기식이란 하고자 하는 작업이 A,B,C일 때<br/>
        A를 시작하고 끝내고<br/>
        B를 시작하고 끝내고<br/>
        C를 시작하고 끝내는 방식을 말한다.<br/>
        보통 대부분 동기식(Synchronous)이다.<br/>
        비동기 식은 각각의 작업을 모두 마치는데 오랜 시간이 걸릴 경우에 주로 사용한다.<br/>
        예를 들어 A의 작업 시간이 15분쯤 걸린다고 하면 <br/>
        A를 실행하고 끝날 때까지 컴퓨터 화면은 15분간 멈춰있게 된다.<br/>
        사용자는 컴퓨터가 다운되었을 거라고 생각하고 재부팅을 하게 된다.<br/>
        다시 시작해도 컴퓨터 화면은 15분간 멈춰있고 사용자는 또 재부팅을 한다.<br/>
        그래서 대신에 A는 함수의 실행과 동시에 바로 종료를 하고<br/>
        시스템한테 나머지 일을 처리하게 한다.<br/>
        그러면 시스템은 백그라운드에서 조용히 일을 마치고 프로그램한테 일을 끝났음을 알려야 하는데<br/>
        이는 보통 콜백함수를 사용한다.<br/>
        <br/>
        비동기식 함수의 매개변수에는 콜백함수가 있다.<br/>
        콜백함수는 시스템에 의해 호출되므로<br/>
        함수의 매개변수나 반환값 등이 이미 정해져 있어서 이에 맞춰 전달해야 한다.<br/>
        <br/><br/>

        A 시작 리턴 --------------- 실제 종료 콜백 호출<br/>
        B 시작 리턴 -------- 실제 종료 콜백 호출<br/>
        C 시작 리턴 ----------------------- 실제 종료 콜백 호출<br/>
        <br/>
        이런 구조이다. (Asynchronous :어싱크로너스 처리라고 한다)

        <br><br>

        단점 -- 콜백의 지옥 -- > 해결책 : Asyncwake란 기술이 있음.
    
    </p>
</body>
</html>

<script>
    function callback(a,b){
        return a+b;
    }

    function mycall(x,y,callback){
        let result = callback(x,y);
        console.log(x,y,result);
    }
    mycall(4,5,callback); //함수호출 - 세번째 인자로 함수를 전달한다.
    mycall(4,5, function(x,y){return x-y}); //미리 함수 정의 안해두고 실시간으로.
    mycall(4,5,(x,y)=> x*y);
    
</script>